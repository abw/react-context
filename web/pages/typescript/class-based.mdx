import TypesSrc         from '@/web/lib/TSClass/Types.ts?raw'
import CounterSrc       from '@/web/lib/TSClass/Counter.ts?raw'
import CountSrc         from '@/web/lib/TSClass/Count.tsx?raw'
import ControlsSrc      from '@/web/lib/TSClass/Controls.tsx?raw'
import ControlsStepSrc  from '@/web/lib/TSClass/ControlsStep.tsx?raw'
import ControlsStep2Src from '@/web/lib/TSClass/ControlsStep2.tsx?raw'
import BignumSrc        from '@/web/lib/TSClass/Bignum.tsx?raw'
import App              from '@/web/lib/TSClass/App.tsx'
import AppSrc           from '@/web/lib/TSClass/App.tsx?raw'
import { Example, Source } from '@abw/badger-website'

# Typescript and Class Based Components

Things get a little bit more complicated when using class components with
Typescript.  This example is the Typescript equivalent of the
[Counter Class](../counter-class) example which defines a model class which
extends the `Context` base class.

<Example
  Component={App}
  code={AppSrc}
  caption="App.tsx"
  expand
/>

## Types

We need to define three types for this.  The first is the `CounterProps` which
are the same as in the previous example.  These are the properties which can
be passed to the provider for initial configuration.

The second is `CounterState` which defines the properties that the class can
store in its internal state.

The third is `CounterRenderProps` which are the properties that will be stored
in the context and passed to consumers.

<Source
  code={TypesSrc}
  caption="Types.ts"
  expand
/>

## Generator

We then define a class which extends the base class `Context`, passing the
`CounterProps`, `CounterState` and `CounterRenderProps` types as generic
type parameters.

There are three static items that are related to the types.  The `initialState`
defines the default state for the class.  The `initialProps` indicates that the
`count` state variable can be set by the `initialCount` property.  The `actions`
lists the methods that should be converted to callable functions and passed to
consumers.

The other static items shown here enable debugging and set the debug prefix and
color.  Check out the Javascript console to see the debugging messages.

Finally we have the definitions for the `inc` and `dec` methods.

The final step is to wrap this in the `Generator()` function and return the
result as the default export.

<Source
  code={CounterSrc}
  caption="Counter.ts"
  highlightLines="4-8,35"
  expand
/>

## Consumer

Here's the `Count.tsx` component.  This is provided access to the context
via the `Consumer()` wrapper function.  The properties should be typed as
`CounterRenderProps`.

<Source
  code={CountSrc}
  caption="Count.tsx"
  highlightLines="4"
  expand
/>

If you define the function inside the call to `Context.Consumer` then you
don't need to worry about declaring the types of the properties.  Typescript
will be able to infer that automatically.

<Source
  code={ControlsSrc}
  caption="Controls.tsx"
  highlightLines="4"
  expand
/>

As we saw in the previous [Functional Components](functional) example,
additional properties can be defined for a component if necessary.
The properties should by typed with an intersection of `CounterRenderProps`
and the additional properties as show here.

<Source
  code={ControlsStepSrc}
  caption="ControlsStep.tsx"
  highlightLines="4-6,8"
  expand
/>

Or if you define your component inside the call to `Counter.Consumer` then
you just need to add the type for additional properties as parameter to
the `Consumer` generic.

<Source
  code={ControlsStep2Src}
  caption="ControlsStep.tsx"
  highlightLines="3-5,7"
  expand
/>


## Use

If you access the context properties via the `Use` hook then Typescript will
be able to infer the property types automatically.

<Source
  code={BignumSrc}
  caption="Bignum.tsx"
  highlightLines="4"
  expand
/>


