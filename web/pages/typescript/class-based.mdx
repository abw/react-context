import TypesSrc         from '@/web/lib/TSClass/Types.ts?raw'
import CounterSrc       from '@/web/lib/TSClass/Counter.ts?raw'
import CountSrc         from '@/web/lib/TSClass/Count.tsx?raw'
import ControlsSrc      from '@/web/lib/TSClass/Controls.tsx?raw'
import ControlsStepSrc  from '@/web/lib/TSClass/ControlsStep.tsx?raw'
import ControlsStep2Src from '@/web/lib/TSClass/ControlsStep2.tsx?raw'
import BignumSrc        from '@/web/lib/TSClass/Bignum.tsx?raw'
import App              from '@/web/lib/TSClass/App.tsx'
import AppSrc           from '@/web/lib/TSClass/App.tsx?raw'
import { Example, Source, Snippet } from '@abw/badger-website'

# Typescript and Class Based Components

Things get a little bit more complicated when using class components with
Typescript.  This example is the Typescript equivalent of the
[Counter Class](../counter-class) example which defines a model class which
extends the `Context` base class.

<Example
  Component={App}
  code={AppSrc}
  caption="App.tsx"
  expand
/>

## Types

We need to define three types for this.  The first is the `CounterProps` which
are the same as in the previous example.  These are the properties which can
be passed to the provider for initial configuration.

The second is `CounterState` which defines the properties that the class can
store in its internal state.

The third is `CounterRenderProps` which are the properties that will be stored
in the context and passed to consumers.

<Source
  code={TypesSrc}
  caption="Types.ts"
  expand
/>

## Generator

We then define a class which extends the base class `Context`, passing the
`CounterProps`, `CounterState` and `CounterRenderProps` types as generic
type parameters.

There are three static items that are related to the types.  The `initialState`
defines the default state for the class.  The `initialProps` indicates that the
`count` state variable can be set by the `initialCount` property.  The `actions`
lists the methods that should be converted to callable functions and passed to
consumers.

The other static items shown here enable debugging and set the debug prefix and
color.  Check out the Javascript console to see the debugging messages.

Finally we have the definitions for the `inc` and `dec` methods.

The final step is to wrap this in the `Generator()` function and return the
result as the default export.

<Source
  code={CounterSrc}
  caption="Counter.ts"
  highlightLines="4-8,35"
  expand
/>

## Consumer

Here's the `Count.tsx` component.  This is provided access to the context
via the `Consumer()` wrapper function.  The properties should be typed as
`CounterRenderProps`.

<Source
  code={CountSrc}
  caption="Count.tsx"
  highlightLines="4"
  expand
/>

If you define the function inside the call to `Context.Consumer` then you
don't need to worry about declaring the types of the properties.  Typescript
will be able to infer that automatically.

<Source
  code={ControlsSrc}
  caption="Controls.tsx"
  highlightLines="4"
  expand
/>

As we saw in the previous [Functional Components](functional) example,
additional properties can be defined for a component if necessary.
The properties should by typed with an intersection of `CounterRenderProps`
and the additional properties as show here.

<Source
  code={ControlsStepSrc}
  caption="ControlsStep.tsx"
  highlightLines="4-6,8"
  expand
/>

Or if you define your component inside the call to `Counter.Consumer` then
you just need to add the type for additional properties as parameter to
the `Consumer` generic.

<Source
  code={ControlsStep2Src}
  caption="ControlsStep.tsx"
  highlightLines="3-5,7"
  expand
/>


## Use

If you access the context properties via the `Use` hook then Typescript will
be able to infer the property types automatically.

<Source
  code={BignumSrc}
  caption="Bignum.tsx"
  highlightLines="4"
  expand
/>

## defaultProps

If your class component uses `defaultProps` to provide default values for
your properties then you've got a problem.

Typescript [has supported the use of `defaultProps`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx)
since version 3, but it only really works inside the class component.  It
also requires you to mark your properties as being required, even though
they're not.

Consider this example which works correctly but confuses Typescript.
The `initialVolume` property is marked as being optional because a default
value is provided by `defaultProps`.  However typescript will complain when
you try to use `this.props.initialVolume` to set the `volume` state variable
on line 19. It thinks it might be undefined because it's an optional property,
even though we can clearly see that it will always be defined by virtue of the
`defaultProps`.

<Snippet file="typescript/Amplifier1.tsx" expand/>

To "fix" this problem, the Typescript documentation says we should remove the
optional marker (`?`) from the property type.

<Snippet file="typescript/AmplifierProps.tsx" expand/>

It works inside the context class and the previous Typescript error is silenced.
But it's just created another problem.  When you try to use your context
provider you'll get a Typescript error telling you that you forgot to include
the `initialVolume` property.  This is because the provider is using the
`AmplifierProps` to type check the `Provider` and according to that, the
`initialVolume` property is mandatory.

<Snippet file="typescript/UseAmplifier.tsx" expand/>


<div class="flex gap-8 mar-t-8">
  ![frustration](../frustration.gif)
  <div>
    <h1 className="mar-v-none">Typescript is not the messiah.</h1>
    <h2 className="mar-t">It's a very naughty boy.</h2>
  </div>
</div>

There are no simple solutions that I can find or come up with, despite many
hours wasted randomly mashing away at the keyboard like a demented monkey.

The best I could come up with were a number of sub-optimal workarounds.
If anyone has any better solutions than these then I'd love to hear them.

### Workaround 1

The first option is to move `defaultProps` out of the class into a regular
constant object (lines 1-3 below).  Set the type for those properties to be
optional (line 6) and defensively code around any places where you access
those properties to fall back on your `defaultProps` (line 19).

<Snippet
  file="typescript/AmplifierWorkaround1.tsx"
  highlightLines="1-3,6,19"
  expand
/>

### Workaround 2

Another option is to do a little extra work up front and define something
like `this.config` that contains a combination of the `defaultProps` and
`props`.  This is shown in the example below.

<Snippet
  file="typescript/AmplifierWorkaround2.tsx"
  highlightLines="5-11,14,17,21-24,26,29-33"
  expand
/>

To be able to type it properly you'll need to split your props
type into two separate types: one for all the properties that are in
`defaultProps` (`AmplifierDefaultProps` on lines 5-7) and one for those that
aren't (`AmplifierRegularProps` on lines 8-10).  Combine them into a single
type (`AmplifierProps` on line 11) to use for the Context props.

Then inside your class object you can type `config` as the intersection of
the regular property type (`AmplifierRegularProps`) and a `Required` version
of the type for the default props (`AmplifierDefaultProps`), as shown on line
17.

Then you can define `this.config` to be a combined spread of `defaultProps`
and `props` (lines 21-24).  Now you can safely access `this.config.initialVolume`
on line 26 and Typescript will be able to tell that this value is always
defined as a number.

One thing to bear in mind: if your properties are likely to change then you
should implement a `componentDidUpdate()` method to re-generate `this.config`
from the new set of `props` (lines 29-33).

### Workaround 3

If you find that all to be a bit messy then another approach is to define a
single type for your props and use the `WithRequired` utility type to
selectively convert the relevant values from optional to required.

<Snippet
  file="typescript/AmplifierWorkaround3.tsx"
  highlightLines="1,8-12,23,32,33"
  expand
/>

The `WithRequired` utility type is used to convert the
two optional properties, `initialVolume` and `initialColour` in the
`AmplifierProps` on lines 8-12, into required properties for `this.config`
on line 23.

Once again, you can then safely use the values in `this.config` on lines
32 and 33 without fear of Typescript getting all up in your shit.  See the
note in the previous workaround about the possible need to add a
`componentDidUpdate()` method.  It's not included in this example for the
sake of brevity.

### Workaround 4

If you've got a lot of default properties then it can be a bit tedious
(and potentially error prone) to explicitly list all the keys in the
`defaultProps` when you call `WithRequired`.

A better approach in this case is to use the `WithRequiredFrom` utility
type that allows you to pass the `typeof defaultProps` as the second
argument and it will extract all the relevant keys.

<Snippet
  file="typescript/AmplifierWorkaround4.tsx"
  highlightLines="1,9"
  expand
/>
